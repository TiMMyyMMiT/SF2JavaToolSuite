name: Dependency-Aware Build

on:
  push:
    branches: [main]
    paths:
      - '**/version.properties'
  pull_request:
    branches: [main]
    paths:
      - '**/version.properties'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Install Ant
        run: |
          sudo apt-get update
          sudo apt-get install -y ant

      - name: Detect changed projects and resolve dependencies
        id: project-graph
        shell: bash
        run: |
          git fetch origin ${{ github.event.before }}

          # Find changed version.properties files
          changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep 'version.properties' || true)

          echo "Changed files:"
          echo "$changed_files"

          changed_projects=()
          for file in $changed_files; do
            project=$(dirname "$file")
            changed_projects+=("$(basename "$project")")
          done

          echo "Changed projects: ${changed_projects[@]}"

          # Export changed projects to environment
          echo "CHANGED_PROJECTS=${changed_projects[*]}" >> $GITHUB_ENV

          declare -A dependencies

          # Parse project.properties for changed projects and recursively for dependencies
          parse_deps() {
            local proj="$1"
            # Avoid re-parsing
            if [[ -n "${dependencies[$proj]+x}" ]]; then
              return
            fi

            local props_file="${proj}/nbproject/project.properties"
            local deps=""
            if [ -f "$props_file" ]; then
              while IFS= read -r line; do
                if [[ "$line" =~ ^project\..*=.*$ ]]; then
                  ref_path=$(echo "$line" | cut -d'=' -f2 | xargs)
                  ref_name=$(basename "$ref_path")
                  deps="$deps $ref_name"
                fi
              done < "$props_file"
              deps=$(echo "$deps" | xargs) # trim whitespace
              dependencies["$proj"]="$deps"
              # Recursively parse dependencies
              for d in $deps; do
                parse_deps "$d"
              done
            else
              echo "Warning: $props_file not found"
              dependencies["$proj"]=""
            fi
          }

          for proj in "${changed_projects[@]}"; do
            parse_deps "$proj"
          done

          echo "Discovered dependencies:"
          for proj in "${!dependencies[@]}"; do
            echo "  $proj -> ${dependencies[$proj]}"
          done

          build_set=()
          visited=()

          resolve_deps() {
            local proj="$1"
            if [[ " ${visited[@]} " =~ " ${proj} " ]]; then return; fi
            visited+=("$proj")
            for dep in ${dependencies[$proj]}; do
              resolve_deps "$dep"
            done
            build_set+=("$proj")
          }

          for proj in "${changed_projects[@]}"; do
            resolve_deps "$proj"
          done

          echo "Build order:"
          for proj in "${build_set[@]}"; do
            echo "$proj"
          done

          # Export build order (space separated) for next step
          echo "BUILD_ORDER=${build_set[*]}" >> $GITHUB_ENV

      - name: Build projects in dependency order
        shell: bash
        run: |
          echo "Building projects in order:"
          mkdir -p built-jars

          # Read arrays from env vars
          read -a BUILD_ORDER <<< "$BUILD_ORDER"
          read -a CHANGED_PROJECTS <<< "$CHANGED_PROJECTS"

          for proj in "${BUILD_ORDER[@]}"; do
            echo "Building $proj..."

            # Copy dependencies' jars into this project's lib/
            for dep in "${BUILD_ORDER[@]}"; do
              if [ "$dep" == "$proj" ]; then break; fi
              if [ -f "built-jars/$dep.jar" ]; then
                echo "  Adding $dep.jar to $proj/lib/"
                cp "built-jars/$dep.jar" "$proj/lib/"
              fi
            done

            # Determine target: changed projects use package-for-store, others jar
            target="jar"
            for changed in "${CHANGED_PROJECTS[@]}"; do
              if [ "$proj" == "$changed" ]; then
                target="package-for-store"
                break
              fi
            done

            echo "Using target: $target"
            ant -f "$proj" -Dnb.internal.action.name=rebuild -Dplatforms.JDK_17.home="$JAVA_HOME" clean
            mkdir -p "$proj/build/classes"
            mkdir -p "$proj/dist/lib"
            # Fix for lib
            if [ -e "$proj/lib" ] && [ ! -d "$proj/lib" ]; then
              echo "Removing file at $proj/lib to create directory"
              rm -f "$proj/lib"
            fi
            mkdir -p "$proj/lib"
            ant -f "$proj" -Dnb.internal.action.name=rebuild -Dplatforms.JDK_17.home="$JAVA_HOME" "$target"

            # Move built jar to shared location
            jar_name=$(basename "$proj")
            if [ -f "$proj/dist/${jar_name}.jar" ]; then
              cp "$proj/dist/${jar_name}.jar" "built-jars/$jar_name.jar"
            else
              echo "Warning: $proj/dist/${jar_name}.jar not found"
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jars
          path: built-jars/*.jar
